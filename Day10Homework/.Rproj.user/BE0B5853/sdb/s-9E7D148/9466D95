{
    "contents" : "---\ntitle: \"Day 10 Lecture\"\noutput: \n  html_document:\n    fig_height: 3\n    fig_width: 5\n    theme: flatly\n    toc: yes\n---\n\n# 0. Setup\n```{r}\nlibrary(ggplot2)\n```\n\n# 1. Miscellaneous notes\n-If you subset something, it has to already exist (important to know for making loops if you're storing results in a dataframe)\n\nHow to create a dataframe with 4 columns and 4 rows, all consisting of NAs:\n```{r}\nx <- rep(NA, 4)\ndf <- data.frame(x, x, x, x)\ndf\n```\n\n# 2. Simulations\nWhat do we mean by \"simulations\"?\n  1. Generate some data\n  2. Do some analysis\n  3. Repeat! (a lot, usually)\n\n# 3. Important functions\n   - distribution functions\n    - e.g., `rnorm()`\n   - mvrnorm\n   - replicate\n   - simulate\n   - sims via loop\n   - system.time\n\n# 4. Distributions\n?Distributions tells you the functions for the distributions that exist in the stats package\n- there are d, p, q, and r for everything\n\n**dnorm()** gives you a density function\n```{r}\n# sequence from -3 to 3, stepping by .05\nnorm.d <- data.frame(x = seq(-3, 3, .05))\n\nnorm.d$y <- dnorm(norm.d$x)\n```\n\n**pnorm()** gives you a p-value\n```{r}\nggplot(norm.d, aes(x, y)) + geom_line()\n\n2*(1 - pnorm(1.96))  # get p-value - here, specifically the 2-tailed p-value for 0.05\n```\n\n**qnorm()** gives you the critical value for some p\n```{r}\nqnorm(.975)          \n```\n\n**rnorm()** gives you the specified number of numbers from a normal distribution\n```{r}\nnorm.data <- data.frame(x = rnorm(1000))\nhead(norm.data)\nggplot(norm.data, aes(x)) + geom_histogram()\n```\n\nrnorm() can take different values for mean and sd\n```{r}\nnorm.data2 <- data.frame(x = rnorm(1000, mean = 20, sd = 10))\nhead(norm.data2)\nggplot(norm.data2, aes(x)) + geom_histogram()\nggplot(norm.data2, aes(scale(x))) + geom_histogram() # the defaults for `scale()` normalize the vector\n```\n\n# 5. Running some simulations\n**nvrnorm()** creates a multivariate normal distribution; its arguments include:\n  -a number of samples (n)\n  -a vector of means (mu)\n  -a correlation matrix (Sigma)\n```{r}\nlibrary(MASS) # MASS = modern applied statistics with S\n\ncor.data <- mvrnorm(n = 100, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), nrow = 2))\ncor(cor.data[, 1], cor.data[, 2])  \n\n# as you increase the number of samples, the correlation will approach the correlation matrix value:\ncor.data <- mvrnorm(n = 10000, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), nrow = 2))\ncor(cor.data[, 1], cor.data[, 2]) \n```\n\n## A. Example related to p-hacking  \nThe function below (that Scott created) \"simA\" simulates a case where you have an experiment with 2 DVs that are correlated with each other and you're not sure which is the best one  \n  \nCreating function simA\n```{r}\nsimA <- function(k = 20, n.cond = 2) {\n  dvs <- mvrnorm(n = k*n.cond, mu = c(0,0), Sigma = matrix(c(1, .5, .5, 1), nrow = 2))\n  this.data <- cbind(data.frame(condition = c(rep(\"A\", k), rep(\"B\", k))), dvs)\n  colnames(this.data) <- c(\"condition\", \"DV1\", \"DV2\")\n  this.data$DV12 <- apply(this.data[, c(\"DV1\", \"DV2\")], 1, mean) # getting mean of D1 and D2\n\n  # doing t-tests with DV1, DV2 and the mean of DV1 and DV2\"\"\n  t1.p <- t.test(DV1 ~ condition, this.data)$p.value\n  t2.p <- t.test(DV2 ~ condition, this.data)$p.value\n  t3.p <- t.test(DV12 ~ condition, this.data)$p.value\n  return(c(t1.p, t2.p, t3.p))\n}\n```\n\nRunning simulations\n```{r}\n# Method 1 of running simA 1000 times (the code within system.time):\n  # system.time() tells you how long the code within takes to run\nsystem.time(sims <- replicate(1000, simA()))\n\n\n# Method 2 of running simA 1000 times:\nsim.results <- data.frame(t1 = rep(NA, 1000), t2 = NA, t3 = NA)\nsystem.time(for(i in 1:1000) {\n  sim.run <- simA()\n  sim.results[i, ] <- sim.run\n})\n\n# Method 3 of running simA 1000 times (this is slower, don't run!)\n# sim.results <- data.frame(t1 = NA, t2 = NA, t3= NA)  # slower\n#system.time(for(i in 1:1000) {\n#  sim.run <- simA()\n#  sim.results[i, ] <- sim.run\n#})\n\n# t() = transpose\nsims <- t(sims)\n  \nsims.df <- as.data.frame(sims)\n\nhead(sims.df)\n```\n\nChecking false positive rates\n```{r}\nnrow(sims.df[sims.df$V1 < .05, ])/nrow(sims.df)\nnrow(sims.df[sims.df$V2 < .05, ])/nrow(sims.df)\nnrow(sims.df[sims.df$V3 < .05, ])/nrow(sims.df)\n```\n\nChecking whether any of the p-values were less than .05 and then calculating new false positive rate\n```{r}\n# 1. Checking whether any of the p-values were less than .05\nsims.df$sig <- apply(sims.df, 1, function(x) any(x < .05))  # (note: this is an example of an anonymous function)\n\n# 2. Calculating new false positive rate -- now it's 10% -- so don't p-hack!\nnrow(sims.df[sims.df$sig, ])/nrow(sims.df)\n```\n\n## B. Another example\nThe function below (that Scott created) \"simB\" simulates a case where you run 10 more people  \n  \nCreating function simB\n```{r}\nsimB <- function(k = 20, k.plus = 10) {\n  dvs <- mvrnorm(n = (k+k.plus)*2, mu = c(0,0), Sigma = matrix(c(1, .5, .5, 1), nrow = 2))\n  this.data <- cbind(data.frame(condition = c(rep(\"A\", k+k.plus), rep(\"B\", k+k.plus)), dataset = c(rep(\"base\", k), rep(\"extra\", k.plus), rep(\"base\", k), rep(\"extra\", k.plus))), dvs)\n  colnames(this.data) <- c(\"condition\", \"dataset\", \"DV1\", \"DV2\")\n  this.data$DV12 <- apply(this.data[, c(\"DV1\", \"DV2\")], 1, mean)\n\n  t1base.p <- t.test(DV1 ~ condition, this.data[this.data$dataset == \"base\", ])$p.value\n  t1extra.p <- t.test(DV1 ~ condition, this.data)$p.value\n  t2base.p <- t.test(DV2 ~ condition, this.data[this.data$dataset == \"base\", ])$p.value\n  t2extra.p <- t.test(DV2 ~ condition, this.data)$p.value\n  t12base.p <- t.test(DV12 ~ condition, this.data[this.data$dataset == \"base\", ])$p.value\n  t12extra.p <- t.test(DV12 ~ condition, this.data)$p.value\n  return(c(t1base.p, t1extra.p, t2base.p, t2extra.p, t12base.p, t12extra.p))\n}\n```\n\nRunning simulations\n```{r}\nsystem.time(sims <- replicate(1500, simB()))\n  \nsims <- t(sims)\n  \nsims.df <- as.data.frame(sims)\n```\n\nChecking false positive rates\n```{r}\nnrow(sims.df[sims.df$V1 < .05, ])/nrow(sims.df)\nnrow(sims.df[sims.df$V2 < .05, ])/nrow(sims.df)\nnrow(sims.df[sims.df$V3 < .05, ])/nrow(sims.df)\n```\n\nChecking whether any of the p-values were less than .05 and then calculating new false positive rates\n```{r}\nsims.df$sigB1 <- apply(sims.df[, 1:2], 1, function(x) any(x < .05))\nnrow(sims.df[sims.df$sigB1, ])/nrow(sims.df)\n\nsims.df$sigB1 <- apply(sims.df[, 1:6], 1, function(x) any(x < .05))\nnrow(sims.df[sims.df$sigB1, ])/nrow(sims.df)\n```\n\n## C. Example using simulate()\n**simulate()** takes a regression model and simulates values using that model\n```{r}\nmysleep <- sleep\nsleep.lm <- lm(extra ~ group, data = mysleep)\nsummary(sleep.lm)\nanova(sleep.lm)\nt.test(extra ~ group, data = mysleep, var.equal = TRUE)\n```\n\nUsing simulate()\n```{r}\nsleep.sims <- simulate(sleep.lm, 2) # simulate the sleep.lm model twice\nsleep.sims$group <- mysleep$group\nsleep.sims\n\nt.test(sim_2 ~ group, data = sleep.sims, var.equal = TRUE)\n\nsummary(sleep.sims) # each column is data from a simulation\n```\n\nNote: if you wanted to examine multiple simulations, you could melt them all down and then run a regression on the resulting column of simulation results\n\n# 6. Some git stuff\n\nMaking changes\n\n1. use `git status` to find out what changes are committed or not yet staged for commit\n2. add files\n    - different procedures depending on whether it's a file or folder\n        - use `git add .` for everything\n        - use `git add day9/` for a folder\n        - use `git add day9.csv` for a file\n    - to undo adding something, use `git reset HEAD day9/`\n3. commit changes\n    - use `git commit -m`\n    - use `git commit -m \"Day 10 update\"` (for a specific folder?)\n4. before pushing, it's good practice to pull first using `git pull origin master`\n5. push your changes using `git push origin master` \n    - note: this is just to push onto the internet\n\nOther stuff\n\n- you can rewind to view older files using `git log --oneline -10` (not really sure this is correct)\n- you can change default text editor using `git config`\n- branching: mostly useful when working with other people or if doing alternate analyses\n    - use `git log -2`",
    "created" : 1421530329035.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2290727942",
    "id" : "9466D95",
    "lastKnownWriteTime" : 1421531248,
    "path" : "~/Documents/UMD and CASL/Classes/R Class/Day 10/day10_lecture.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}